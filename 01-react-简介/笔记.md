
# react简介

## 特点
1. 组件化模式，声明式（与命令式相对应）编码。
2. 在React Native（React的后续高级进阶知识）中使用React语法进行移动端开发。
3. 使用虚拟DOM+优秀的Diffing算法，尽量减少与真实DOM的交互。

## HTML页面引入react
1. babel.min.js
   + a.ES6语法转ES5,import等
   + b.jsx转js(jsx为js类似，提供一些独有功能，参考微信小程序);
2. react.development.js
   + react核心库
3. react-dom.development.js
   + react拓展库，（辅助react操作DOM）
4. prop-types.js
   + (暂时用不上)

**页面引入注意事项**
1. 需要先引入核心块`react.development.js`,在引入拓展块`react-dom.development.js`
2. 总共引入3个模块，最后引入`babel.min.js`
3. 书写`js`的`srcip`标签的`type`属性值必须为`text/babel`,而不是`js`或者是`jsx`，不写默认是`js`

**过程**
1. 创建虚拟DOM
   ```javascript
   const VDOM = <h1>Hello,React</h1>
   //此处值不需要添加字符串引号，因为值为虚拟DOM,jsx语法。
   ```
2. 渲染虚拟DOM到页面
   类似于jQuery的引入，全局有一个jquery对象和一个$，引入`react.devlopment`则具有一个全局对象 `React`,引入`react-dom.development.js`则默认具有一个全局对象`ReactDOM`
   
   ```javascript
   ReactDOM.render(虚拟DOM,挂载DOM的容器);
   ReactDOM.render(VDOM,document.getElementById('app'))//react没有提供选择器功能，必须要手动获取。
   ReactDOM.render(VDOM1,document.getElementById('app'))//该动作为替换，而不是追加，所以展示的是VDOM1中的内容，而不是VDOM,VDOM1均展示
   ```
# 虚拟DOM的两种创建方式

## 使用JSX创建
```javascript
   const VDOM = <h1 id="title">Hello,React</h1>;
   ReactDOM.render(VDOM,document.getElementById('app'));
```
## 使用原生JS创建
   此时不需要导入`babel.min.js`,因为不需要它转换`JSX语法`。
```javascript
const VDOM = React.createElement('h1',{id:'title',className:'first'},'Hello,React');
//区别于document.createElement()创建的真实DOM,React.elementElement创建的是虚拟DOM
ReactDOM.render(VDOM,document.getElementById('app'));
```
   如果此时需要在`h1`标签里面嵌套一个`span`标签，此时必须使用
   ```javascript
   const VODM = React.createElement('h1',{id:'title',className:'first'},React.createElement(
      'span',{id:'amt',className="amt'},'Hello,React'));
//而不是
   const VDOM = React.createElement('h1',{id:'title',className:'first'},'<span>Hello,React</span>')；//标签体内的内容不能添加标签
   ```
   如果有多层复杂的嵌套关系，则`JSX`明显比`JS`要方便很多，这也是为什么会有`JSX`语法的缘故。因为`JSX`可以比较简单的创建虚拟DOM.
   **复杂的JSX语法**
   ```javascript
      const VDOM = (
         <h1 id="title" class="first">
            <span id="amt" class="amt">
               Hello,React
            </span>
         </h1>
      );
      //小括号括起来代表一个整体
   ```
   其实`JSX`经过`babel`翻译之后，转换成的依然还是可被浏览器识别的`原生JS`所创建的虚拟DOM方式，也就是`使用原生创建`的方式，可以说`JSX`就是为简化虚拟DOM的创建而诞生的`JS`语法糖。

## 虚拟DOM的特点
```javascript
<script type="text/javascript">
    const VDOM = React.createElement('h1',{id:'h1'},React.createElement('span',{className:'span'},'Hello,React,Ha,Ha,Ha'));
    const element = document.getElementById('app');
    ReactDOM.render(VDOM,element);
    console.log('虚拟DOM',VDOM);
    console.log('真实DOM',element);
    debugger;
</script>
```
**虚拟DOM与真实DOM**

1. 本质是Object类型的对象（一般对象）。
2. 虚拟DOM比较"轻"，属性比较少，只有React内部在使用。
3. 真实DOM比较"重"，具有DOM所需的全部属性。
4. 虚拟DOM最终会被React转化为真实DOM,呈现在页面上。



# JSX语法

全称JavaScript XML，react定义的一种类似于XML的JS拓展语法：JS+XML。本质是`React.createElement(component,props,...children)`方法的语法糖。

作用：用来简化创建虚拟DOM。



## JSX语法规则

1. 定义虚拟DOM时，不要写引号。
2. 标签中混入JS表达式时要用{}。
3. 样式的类名指定不要用class,要用className。（避免与ES6中的class相冲突）。
4. 内联样式要采用 style={{key:value}},这种形式。（外层{}表示一个内容为一个JS表达式，里层的{}表示JS表达式不是一个函数，或者一个变量，而是一个JS的一般对象）
5. 虚拟DOM必须只有一个根标签。
6. 标签必须闭合。
7. 标签首字母

   + 若小写字母开头，则将该标签转为html中的同名标签，若html中没有该标签对应的同名元素，则直接报错。
+ 若大写字母开头，react就去渲染对应的组件，若组件没有定义，则直接报错。

## JS语句(代码)与表达式的区别

​      *一定注意区分：【js语句(代码)】与【js表达式】*

1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方.

​                下面这些都是表达式：

​                    *(1). a*

​                    *(2). a+b*

​                    *(3). demo(1)*

​                    *(4). arr.map()* 

​                    *(5). function test () {}*

2. 语句(代码)：

​                下面这些都是语句(代码)：

​                    *(1).if(){}*

​                    *(2).for(){}*

​                    (3).switch(){case:xxxx}

<font color="red">React中只允许书写JS表达式而不是JS语句</font>

  如果React传入一个数组，则React自动会遍历这个数组，同时数组里面的元素'<li>Angular</li>'会自动渲染成DOM。

  如果给React传入一个对象，则会直接报错。



# 组件与模块

## 模块

1. 理解：向外提供特定功能的js程序, 一般就是一个js文件。

2. 为什么要拆成模块：随着业务逻辑增加，代码越来越多且复杂。

3. 作用：复用js, 简化js的编写, 提高js运行效率。





## 组件

1. 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image等等)。

2. 为什么要用组件： 一个界面的功能更复杂。

3. 作用：复用编码, 简化项目编码, 提高运行效率。



## 模块化

当应用的js都以模块来编写的, 这个应用就是一个模块化的应用。



## 组件化

当应用是以多组件的方式实现, 这个应用就是一个组件化的应用。







# React面向组件编程



**react组件特点**

1. <font color="red">组件名必须首字母大写。</font>

2. 虚拟DOM元素只能有一个根元素。

3. 虚拟DOM元素必须有结束标签。



## 函数式组件

用函数定义出来的组件被称为函数式组件。

```html
<script type="text/babel">
	//1.创建函数式组件
    function MyComponent(){
    	console.log(this);//babel编译好开启了严格模式，所以this打印出来为undefined
        return <h2>我是用函数式定义的组件(适用于【简单组件】)的定义</h2>
    }
    //2.渲染组件到页面
    ReactDOM.render(<MyComponent/>,document.getElementById('app'));
</script>
//以上的函数可以直接拷贝到babel官网上去运行，可以查看JSX语法最终被转换的效果。
```

~~~html
<script type="text/babel">
    //1.创建函数式组件
    const title = 'title';
    const content = 'Hello,React';
    function MyComponent(){
        return <h1 className={title}>{content}</h1>;
    };
    const element = document.querySelector('.app');
    //2.渲染组件
    ReactDOM.render(<MyComponent/>,element);
</script>
~~~

**过程：**

1. React解析组件标签（大写开头标签名，如果小写的直接与html标签想映照）。找到了MyComponent组件，找不到则直接报错。
2. 发现组件采用了函数定义的方式创建，随后调用了该函数，将返回的虚拟DOM转为真实DOM,随后渲染到页面上呈现。

**注意：**

1. 函数名首字母必须大写（因为JSX语法只有当组件首字母大写才会被直接渲染成组件，小写字母直接与html元素比较，然后渲染或者报错）。

2. 组件标签必须要闭合。（JSX语法规定组件必须闭合）













## 类式组件

用类定义出来的组件被称为类式组件。



### ES6中的类

```javascript
//创建一个Person类
class Person{
    //构造器方法
    constructor(name,age){
        //构造器中的this指向类的实例对象
        this.name = name;
        this.age = age;
    }
    //一般方法（除开构造器函数，业务自己定义的方法）
    speak(){
        //speak方法放在了类的原型对象上，供实例使用
        //通过Person实例调用speak时，speak中的this就是Person的实例(除非该方法调用了call,apply,bind之类的方法改变了函数内部this的指向)  
        console.log(this);
        console.log(`我叫:${this.name},我年龄是:${this.age}`)
    }
}
//创建一个Person的实例对象
const p1 = new Person('Tom',18);
const p2 = new Person('Jerry',19);
p1.speak();
p2.speak();
new Person('Smith',18).speak();
new Person('Alice',19).speak.call({name:'Faker',age:25});
```



**创建一个Student类，继承Person类**

```javascript
//创建一个Student类，继承了Person类
class Student extends Person{
    //Student构造器方法,可写，可不写，如果Student需要额外的属性，则必须添加，否则可以不添加，直接继承父类的构造器。
    constructor(name,age,grade){
        super(name,age);//如果有extends,且有constructor，则必须通过super来调用父类的构造器，且super必须在构造器的第一行
        this.grade = grade;
    }
    //重写从父类继承过来的方法
    speak(){
        console.log(this);
        console.log(`我叫:${this.name},我年龄是:${this.age},我读的是${this.grade}`)
    }
    study(){
        //study方法放在了Student类的原型对象上，供Student实例使用
        //通过Student实例调用study时，study中的this就是Student的实例
        console.log('我很努力的学习')
    }
}
//直接使用父类的构造器
const s1 = new Student('小张',15);
//使用子类的构造器
const s2 = new Student('小张',18,'高中');
s2.speak();//继承父类的方法
```





### 类式组件

```html
<script type="text/babel">
//1.创建类式组件
class MyComponent extends React.Component {
	//render方法在MyComponent原型对象上，供实例对象使用。
	render(){
		//render里面的this指向MyComponent的实例对象《==》MyComponent组件实例对象。
	    console.log(this)
		return <h2>我是用类定义的组件（适用于【复杂组件】的定义）</h2>
	}
}
//2.渲染组件到页面
ReactDOM.render(<MyComponent/>,ele);
</script>
```

**过程**

1. React解析组件标签，找到了MyComponent组件。
2. 发现组件是使用类定义的，随后new出来该类的实例，并通过该实例调用原型对象上的render方法。
3. 将render返回的虚拟DOM转为真实DOM，随后呈现在页面中。



## 简单组件与复杂组件





